import { Telephony } from "@/services/telephony/types";
import {
    BaseMessagePromptTemplate,
    ChatPromptTemplate,
} from "@langchain/core/prompts";
import { VapiClient } from "@vapi-ai/server-sdk";
import {
    ArtifactMessagesItem,
    CreateAssistantDto,
    OpenAiMessage,
    ToolCallResultMessage,
} from "@vapi-ai/server-sdk/api";
import { PhoneNumber } from "schema";
import { config } from "shared/src/config";
import { unreachableCaseError } from "shared/src/error";
import { unindented } from "shared/src/format";
import { assert, notImplemented } from "shared/src/function";

const client = new VapiClient({ token: config("VAPI_API_PRIVATE_KEY") });

type AcceptedCallProvider = "openai";
const DEFAULT_CALL_PROVIDER = "openai";

/**
 * Utility function to create a call model for Vapi with the given system messages.
 */
const createCallModel = (
    provider: Extract<
        CreateAssistantDto["model"],
        { provider: AcceptedCallProvider }
    >["provider"],
    systemPrompt: ChatPromptTemplate,
): CreateAssistantDto["model"] => {
    switch (provider) {
        case "openai": {
            const messages: OpenAiMessage[] = systemPrompt.promptMessages.map(
                (message): OpenAiMessage => {
                    if (message instanceof BaseMessagePromptTemplate) {
                        throw new Error(
                            "vapi.createCallModel: Expected a message prompt, received template",
                        );
                    }

                    if (typeof message.content !== "string") {
                        throw new Error(
                            "vapi.createCallModel: Received MessageContentComplex, expected string",
                        );
                    }

                    const messageType = message.getType();
                    switch (messageType) {
                        case "system": {
                            return {
                                role: "system",
                                content: message.content,
                            };
                        }

                        case "human": {
                            return {
                                role: "user",
                                content: message.content,
                            };
                        }

                        case "function":
                        case "tool":
                        case "ai":
                        case "generic":
                        case "developer":
                        case "remove": {
                            return notImplemented();
                        }

                        default: {
                            throw unreachableCaseError(messageType);
                        }
                    }
                },
            );

            return {
                provider,
                model: "gpt-3.5-turbo",
                messages,
            };
        }

        default: {
            throw unreachableCaseError(provider);
        }
    }
};

export const vapi = {
    transcription: {
        getTranscription: async (telephoneCallExternalServiceId: string) => {
            const call = await client.calls.get(telephoneCallExternalServiceId);

            if (!call.artifact?.messages) {
                return undefined;
            }

            // Transcript is just inferred from messages by vapi for convenience.
            assert(
                call.artifact.transcript !== undefined,
                "Expected a transcript",
            );

            // ToolCallResultMessage is a message that is generated by the tool, and has no content
            // so we can just skip over those.
            const isMessageWithContent = (
                message: ArtifactMessagesItem,
            ): message is Exclude<
                ArtifactMessagesItem,
                ToolCallResultMessage
            > => {
                return (message as any).toolCallId === undefined;
            };

            const messages = call.artifact.messages
                .filter((message) => isMessageWithContent(message))
                .map((message) => {
                    return { role: message.role, message: message.message };
                });

            return {
                messages,
                transcription: call.artifact.transcript,
            };
        },
    },

    phone: {
        getPhoneNumberId: async () => {
            const phoneNumbers = await client.phoneNumbers.list();
            assert(
                phoneNumbers.length === 1,
                "Expected exactly one phone number in vapi",
            );

            const phoneNumber = phoneNumbers[0];
            return phoneNumber.id;
        },

        /**
         * # TODO => Maybe seperate out the order creation into a seperate service.
         */
        call: async (rawOutboundPhoneNumber, firstMessage, systemPrompt) => {
            /**
             *
             * ðŸš¨ ðŸš¨ ðŸš¨
             *
             * In local development, we use a stub phone number to avoid
             * actually calling a real phone number.
             *
             * I am putting this here intentionally.  I also probably will put this
             * above in the generic provider.
             *
             * ðŸš¨ ðŸš¨ ðŸš¨
             *
             */
            const outboundPhoneNumber =
                config("NODE_ENV") === "local"
                    ? config("VAPI_STUB_PHONE_NUMBER")
                    : rawOutboundPhoneNumber;

            const isOutBoundPhoneNumberValid =
                PhoneNumber.safeParse(outboundPhoneNumber).success;

            if (!isOutBoundPhoneNumberValid) {
                throw new Error(
                    unindented`
                        vapi.phone.call: Invalid phone number: ${outboundPhoneNumber}.
                        Hot tip: you probably are missing US country code or leading plus sign (+1).
                    `,
                );
            }

            const phoneNumberId = await vapi.phone.getPhoneNumberId();
            const model = createCallModel(DEFAULT_CALL_PROVIDER, systemPrompt);

            const call = await client.calls.create({
                phoneNumberId,
                assistant: {
                    maxDurationSeconds: 120,
                    backgroundSound: "office",
                    transcriber: {
                        provider: "deepgram",
                        // # TODO => Enable code switching, which let's us switch languages mid-call.
                        // codeSwitchingEnabled: true
                    },
                    firstMessageMode: "assistant-waits-for-user",
                    firstMessage,
                    model,
                },
                customer: {
                    number: outboundPhoneNumber,
                },
            });

            return {
                telephoneCallExternalServiceId: call.id,
            };
        },
    },
} satisfies Telephony;
